setwd("/Users/jonatanbadillo/Desktop/UNIVERSITY/Servicio-Social/Data-Mining/Analisis de Datos con R")
# Leer Datos en un archivo de texto:
myCSV<-read.csv ("Datasets/c31.csv", header=TRUE)
str (myCSV)
# Comando Read Table
myTable<-read.table("Datasets/c311.txt", sep="\t", header=TRUE)
str(myTable)
# Leer archivo XLSX
library(xlsx)
ruta <- "Datasets/c311Lot.xlsx"
mydataframe <- read.xlsx(ruta,1)
str(mydataframe)
# Leer archivo XLS
library(XLConnect)
myE1<-loadWorkbook("Datasets/c311Lot1.xls")
# Leer archivo XLSX
library(xlsx)
ruta <- "Datasets/c311Lot.xlsx"
mydataframe <- read.xlsx(ruta,1)
str(mydataframe)
# Leer archivo XLS
library(XLConnect)
myE1<-loadWorkbook("Datasets/c311Lot1.xls")
# Leer archivo XLS
library(XLConnect)
myE1<-loadWorkbook("Datasets/c311Lot1.xls")
mydata<-readWorksheet(myE1,sheet="Lot",header=TRUE)
str(mydata)
install.packages("XLConnect")
install.packages("XLConnect")
install.packages("XLConnect")
install.packages("XLConnect")
install.packages("XLConnect")
View(mydata)
View(mydata)
x<-runif(1, 0, 20)
x
if (x>10) (
print (x)
)else(
print ("x is less than 10")
)
if (x>10) (
print (x)
)else(
print ("x is less than 10")
)
if (x>10) (
print (x)
)else(
print ("x is less than 10")
)
x<-runif(1, 0, 20)
x
x<-runif(1, 0, 20)
x
x<-runif(1, 0, 20)
x
x<-runif(1, 0, 20)
x
if (x>10) (
print (x)
)else(
print ("x is less than 10")
)
# For
x<-c ("Juan", "Beni", "Jorge", "David")
x
for (i in 2:3) (
## Imprime solo 2 elementos
print (x[i])
)
x
for (i in seq_along(x)) (
print (x[i])
)
count<-0
while (count<10) {
print(count)
count=count+1
}
## Imprime solo 2 elementos
apply (cars, 2, mean)
head (cars)
str(apply)
head (cars)
apply (cars, 2, mean)
apply(cars,2,quantile)
# lapply()
# La función lapply() genera los resultados como una list.lapply() y se puede aplicar a una lista, marco de datos o vector.
# La salida siempre es una lista que tiene el mismo número de elementos que el objeto que se pasó a lapply():
str(lapply)
head (cars)
# function (X, FUN, ...)
# X: Conjunto de datos
# FUN: Función
str(cars)
lap <- lapply(cars,mean)
lap
apply(cars,2,quantile)
sap <- sapply(cars, mean)
sap
str(sap)
str(lap)
# tapply()
# Se usa sobre subconjuntos de un vector. La función tapply() es similar a otras funciones apply(), excepto que se aplica sobre un subconjunto de un conjunto de datos:
str (tapply)
tapply(mtcars$mpg, mtcars$cyl, mean)
# Averiguar la potencia promedio (hp) para la transmisión automática y manual,
tapply(mtcars$hp,mtcars$am,mean)
Orange
# Cut()
# Es posible que debas dividir las variables continuas para colocarlas en diferentes contenedores.
Orange
# A continuación, crea cuatro grupos según la edad de los árboles.
# El primer parámetro es el conjunto de datos y la edad, y el segundo parámetro es el número de grupos que se desea crear.
c1<-cut(Orange$age,breaks=4)
table(c1)
seq(100,2000,by=300)
c1<-cut(Orange$age,seq(100,2000,by=300))
c1<-cut(Orange$age,seq(100,2000,by=300))
table(c1)
c2<-cut(Orange$age,seq(100,2000,by=300))
table(c2)
# Split()
# Dividir el conjunto de datos en grupos.
str(split)
c3<-split(Orange,Orange$age)
c3
myFunc(){
# ESCRIBIR FUNCIONES EN R
myFunc <- function(){
print("Mi primera Funcion")
}
myFunc()
View(myFunc)
myFunc2 <- function(num){
for (i in seq_len(num)) {
cat("My function:",i,"\n")
}
}
myFunc2(5)
install.packages("sqldf")
# ELIMINAR DATOS INNECESARIOS
library(sqldf)
install.packages("RSQLite")
install.packages("RSQLite")
# ELIMINAR DATOS INNECESARIOS
library(sqldf)
sqldf("SELECT * FROM mtcars WHERE am=1 AND vs=1")
# Alternativamente:
subset(mtcars,am == 1 & vs == 1)
library(sqldf)
sqldf("SELECT * FROM mtcars WHERE am=1 AND vs=1")
row.names(TRUE)
row.names(TRUE)
sqldf("SELECT * FROM mtcars WHERE am=1 AND vs=1",row.names(TRUE))
identical(
sqldf("SELECT * FROM mtcars WHERE am=1 AND vs=1",row.names = TRUE)
)
identical(
sqldf("SELECT * FROM mtcars WHERE am=1 AND vs=1",row.names = TRUE),subset(mtcars,am == 1 & vs == 1)
)
# Alternativamente:
subset(mtcars,am == 1 & vs == 1)
# Eliminar columnas
subset(mtcars,am == 1 & vs == 1, select = hp:wt)
# Eliminar columnas
subset(mtcars,am == 1 & vs == 1, select = wt)
install.packages("hflights")
system.time(sqldf("SELECT * FROM hflights WHERE Dest == 'BNA'",row.names = TRUE))
library(hflights)
system.time(sqldf("SELECT * FROM hflights WHERE Dest == 'BNA'",row.names = TRUE))
system.time(subset(hflights,Dest== 'BNA'))
(sqldf("SELECT * FROM hflights WHERE Dest == 'BNA'",row.names = TRUE))
system.time(sqldf("SELECT * FROM hflights WHERE Dest == 'BNA'",row.names = TRUE))
system.time(subset(hflights,Dest== 'BNA'))
library(dbplyr)
library(dplyr)
system.time(filter(hflights, Dest == 'BNA'))
str(select(filter(hflights,Dest == 'BNA'),DepTime:ArrTime))
sqldf("SELECT * FROM mtcars WHERE am=1 AND vs=1")
mtcars$rownames <- rownames(cars)
mtcars$rownames <- rownames(mtcars)
select(filter(mtcars, hp>300),c(rownames,hp)
mtcars$rownames <- rownames(mtcars)
select(filter(mtcars, hp>300),c(rownames,hp))
hflights$rownames <- row.names(hflights)
str(select(filter(hflights,Dest == 'BNA'),c(rownames,DepTime:ArrTime))
str(select(filter(hflights,Dest == 'BNA'),c(rownames,DepTime:ArrTime)))
hflights$rownames <- row.names(hflights)
str(select(filter(hflights,Dest == 'BNA'),c(rownames,DepTime:ArrTime)))
str(select(filter(hflights,Dest == 'BNA'),DepTime:ArrTime))
mtcars$rownames <- rownames(mtcars)
select(filter(mtcars, hp>300),c(rownames,hp))
subset(mtcars,am == 1 & vs == 1, select = hp:wt)
subset(mtcars,am == 1 & vs == 1, select = wt)
subset(mtcars,am == 1 & vs == 1, c(hp,wt))
subset(mtcars,am == 1 & vs == 1, c(hp:wt))
subset(mtcars,am == 1 & vs == 1, c(wt))
str(select(filter(hflights,Dest == 'BNA'),DepTime:ArrTime))
# podemos extender esta solución eliminando algunas columnas del conjunto de datos como lo hicimos antes con el subconjunto
str(select(filter(hflights,Dest == 'BNA'),c(DepTime,ArrTime))
str(select(filter(hflights,Dest == 'BNA'),c(DepTime,ArrTime))
# podemos extender esta solución eliminando algunas columnas del conjunto de datos como lo hicimos antes con el subconjunto
str(select(filter(hflights,Dest == 'BNA'),c(DepTime,ArrTime)))
install.packages("data.table")
# ------------------------------------------------------------------------------
# Elimina datos innecesarios de otra manera eficiente
library(data.table)
# transformar el data.frame tradicional de hflights en data.table
hflights_dt <- data.table(hflights)
# creamos una nueva columna, llamada nombres de fila, a la que
# asignamos los nombres de fila del conjunto de datos original con la ayuda del: = operador
# de asignación específico de data.table:
hflights_dt(,rownames := rownames(hflights))
library(data.table)
# transformar el data.frame tradicional de hflights en data.table
hflights_dt <- data.table(hflights)
hflights_dt[,rownames := rownames(hflights)]
system.time(hflights_dt[Dest=='NBA'])
str(hflights_dt[Dest == 'BNA',list(DepTime,ArrTime)])
# veamos cómo podemos seleccionar las columnas en la sintaxis data.table
str(hflights_dt[Dest == 'BNA',c(DepTime,ArrTime)])
str(hflights_dt[Dest == 'BNA',c(DepTime,ArrTime)])
# veamos cómo podemos seleccionar las columnas en la sintaxis data.table
str(hflights_dt[Dest == 'BNA',list(DepTime,ArrTime)])
# aunque el uso de c () se usa más tradicionalmente
hflights_dt[Dest == 'BNA',c(DepTime,ArrTime,with=FALSE)
# aunque el uso de c () se usa más tradicionalmente
hflights_dt[Dest == 'BNA',c(DepTime,ArrTime,with=FALSE]
# aunque el uso de c () se usa más tradicionalmente
hflights_dt[Dest == 'BNA',c(DepTime,ArrTime),with=FALSE]
hflights_dt[Dest == 'BNA',c(DepTime,ArrTime),with=FALSE]
hflights_dt[Dest == 'BNA',c('DepTime','ArrTime'),with=FALSE]
# veamos cómo podemos seleccionar las columnas en la sintaxis data.table
# list se usó para definir las columnas requeridas para mantener
str(hflights_dt[Dest == 'BNA',c('DepTime','ArrTime')])
aggregate(hflights$Diverted, by = list(hflights$DayOfWeek),FUN=mean)
aggregate(hflights$Diverted, by = c(hflights$DayOfWeek),FUN=mean)
aggregate(hflights$Diverted, by = list(hflights$DayOfWeek),FUN=mean)
aggregate(hflights$Diverted,c(hflights$DayOfWeek),FUN=mean)
# De manera alternativa:
with(hflights,aggregate(Diverted,by = list(DayOfWeek), FUN=mean))
# o...
aggregate(Diverted ~ DayOfWeek, data=hflights,FUN = mean)
# ------------------------------------------------------------------------------
# Agregación más rápida con comandos base R
# llamar a la función tapply o by, que puedes aplicar una función R sobre una matriz irregular.
tapply(hflights$Diverted, hflights$DayOfWeek, mean)
# ------------------------------------------------------------------------------
# Funciones convenientes de ayuda
library(plyr)
install.packages("plyr")
# ------------------------------------------------------------------------------
# Funciones convenientes de ayuda
library(plyr)
ddply(hfligts, .(DayofWeek),function(x) mean(x$Diverted))
ddply(hflights, .(DayofWeek),function(x) mean(x$Diverted))
ddply(hflights, .(DayOfWeek),function(x) mean(x$Diverted))
ddply(hflights, .(DayOfWeek),summarise, Diverted=mean(Diverted))
# ------------------------------------------------------------------------------
# Agregado con data.table
hflights_dt[,mean(Diverted),by = DayOfWeek]
setkey(hflights_dt, 'DayOfWeek')
hflights_dt[,mean(Diverted),by = DayOfWeek]
# Ejecución de benchmarks
DPLYR_ALL <- function() {
hflights_DayOfWeek <- group_by(hflights, DayOfWeek)
dplyr::summarise(hflights_DayOfWeek, mean(Diverted))
}
# verificamos que no tenga claves
key(hflights_dt_nokey)
hflights_dt_nokey <- data.table(hflights)
# verificamos que no tenga claves
key(hflights_dt_nokey)
install.packages("microbenchmark")
library(microbenchmark)
res <- microbenchmark(AGGR1(),AGGR2(),AGGR3(),TAPPLY(),PLYR1(),PLYR2(),DPLYR(),DPLYR_ALL(),DT(),DT_KEY(),DT_ALL())
res <- microbenchmark(AGGR1(), AGGR2(), AGGR3(), TAPPLY(), PLYR1(),
+ PLYR2(), DPLYR(), DPLYR_ALL(), DT(), DT_KEY(), DT_ALL())
library(microbenchmark)
res <- microbenchmark(AGGR1(), AGGR2(), AGGR3(), TAPPLY(), PLYR1(),
+ PLYR2(), DPLYR(), DPLYR_ALL(), DT(), DT_KEY(), DT_ALL())
print(res,digits=3)
res <- microbenchmark(AGGR1(), AGGR2(), AGGR3(), TAPPLY(), PLYR1(),
+ PLYR2(), DPLYR(), DPLYR_ALL(), DT(), DT_KEY(), DT_ALL())
library(microbenchmark)
res <- microbenchmark(AGGR1(), AGGR2(), AGGR3(), TAPPLY(), PLYR1(),
+ PLYR2(), DPLYR(), DPLYR_ALL(), DT(), DT_KEY(), DT_ALL())
ddply(hflights, .(DayOfWeek),summarise , n=length(Diverted))
ddply(hflights, .(DayOfWeek),nrow)
table(hflights$DayOfWeek)
count(hflights, 'DayOfWeek')
barplot(data,xlab = "X-axis",ylab = "Y-axis",main = "Bar Chart 1", col = "green")
# Gráfico de barras e histograma
data <- c(4,6,8,10,12,8)
barplot(data,xlab = "X-axis",ylab = "Y-axis",main = "Bar Chart 1", col = "green")
png(filename = "barchart.png", width = 800, height = 600)
barplot(data, xlab="x-axis", ylab="y-axis", main="bar chart 1", col="green")
dev.off()
data <- c(4, 6, 7, 9, 10, 20, 12, 8)
barplot(data, xlab="x-axis", ylab="y-axis", main="bar chart 1",col = "green",horiz = TRUE)
data("mtcars")
data<-table(mtcars$gear,mtcars$carb)
data
View(mtcars)
View(mtcars)
barplot(data, xlab="x-axis", ylab="y-axis", main="bar chart 1", col=c("grey", "blue", "yellow"))
# Un gráfico de barras agrupadas
barplot(data, xlab="x-axis", ylab="y-axis", main="bar chart 1", col=c("grey", "blue", "yellow"),beside=TRUE)
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
# Histogramas
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
histplot(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
set.seed(123)
data1 <- rnorm(100, mean=5, sd=3)
hist(data1, main="histogram", xlab="x-axis", col="green",border="blue", breaks=10)
hist(data1, main="histogram", xlab="x-axis", col="green", border="blue", breaks=10,freq=FALSE)
lines(density(data1), col="red")
x <- c(1, 2, 3, 4, 5, 6, 8, 9)
y <- c(3, 5, 4, 6, 9, 8, 2, 1)
plot(x, y, type="l", xlab="x-axis", ylab="y-axis", main="linegraph", col="blue")
x.1 <- c(2, 3, 4, 6, 7, 8, 9, 10)
y.1 <- c(6, 3, 5, 1, 5, 3, 4, 8)
plot(x, y, type="l", xlab="x-axis", ylab="y-axis", main="linegraph", col="blue")
lines(x.1, y.1, type="o", col="green")
# Grafico circular
x <- c(10, 30, 60, 10, 50)
labels <- c("one", "two", "three", "four", "five")
pie(x, labels, main="Pie Chart")
install.packages("plotrix")
pie3D(x, labels=labels, explode=0.1, main="Pie Chart")
library(plotrix)
pie3D(x, labels=labels, explode=0.1, main="Pie Chart")
x <- c(1, 2, 3, 4, 5, 6, 8, 9)
y <- c(3, 5, 4, 6, 9, 8, 2, 1)
plot(x, y, xlab="x-axis", ylab="y-axis", main="scatterplot")
set.seed(12)
var1 <- rnorm(100, mean=3, sd=3)
var2 <- rnorm(100, mean=2, sd=2)
var3 <- rnorm(100, mean=1, sd=3)
data <- data.frame(var1, var2, var3)
boxplot(data, main="boxplot", notch=FALSE, varwidth=TRUE,col=c("green", "purple", "blue"))
set.seed(12)
var1 <- rnorm(100, mean=3, sd=3)
var2 <- rnorm(100, mean=2, sd=2)
var3 <- rnorm(100, mean=1, sd=3)
var4 <- rnorm(100, mean=2, sd=3)
var5 <- rnorm(100, mean=2, sd=3)
data <- data.frame(var1, var2, var3, var4, var5)
pairs(~var1+var2+var3+var4+var5, data=data, main="scatterplotmatrix")
